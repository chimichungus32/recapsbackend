 All right, so today's lecture, I apologize for the number here. The number is wrong.  I could really quickly fix that. A little bit of a 3.1 today. My apologies. So 3.1,  the first lecture of week three is going to be talking about dynamic verification.  Correctness, dynamic verification, they're all really big words. Colloquially, what we're about  to talk about is known as testing. That means that, you know, you write software, and we're  going to learn how to actually test that software, right? Now, testing is an idea that even if you  don't really feel like you know how to do it, you kind of get the idea of it, right? It's writing  code to check your code. And that's really what we're going to be talking about. So the reason  why we're talking about this today is writing tests are critical to ensure applications work.  That makes sense. If you don't have ways of testing your code, how do you know your code  works, right? You might be really smart, you might think I'm a genius programmer, you might have kind  of put some things into your program before and it seems to give the right output but you know if  you're not sure if you don't have tests then you're not really going to be you know as sure as you  possibly can be uh it's important that we talk about testing in terms of process and methodologies  too because approaching testing the right way will yield better results overall so you can write bad  tests and you can write good tests and we're going to kind of chat a little bit about that as well  and we need to be able to understand the characteristics of programming languages and  approaches to understand how bugs may occur and how you can prevent them. What I mean by that is  that in languages like C compared to something like JavaScript, the types of errors that you  will get will be drastically different. And therefore we need to also approach it differently.  We're talking about some of these theoretical concepts at the start, and then we're going to  go a little bit deeper into Jest, which is a really specific technical aspect of testing in  JavaScript. So there's a little bit of academic theory, and then there's a bit of actually getting  your hands dirty. And most importantly, this lecture is very critical for iteration one,  which I believe you've just had released. So it's very difficult to start iteration one  without having watched this lecture. So if you're watching it live, great job,  you put yourself in the best position. And if you're watching the recording  in week four, I wish you well with whatever you're up to. All right. So firstly, there's  a really important word that we need to unpack. And that word is verification.  Here's a very kind of hefty technical definition.  Verification in a system life cycle context,  that a way of saying like within the context of building big systems and how those processes go is a set of activities that compares a product of the system lifecycle against the required characteristics for  that product. That's quite a big lengthy definition there in bold. So what we're really saying by that  is it's just saying like we are trying to compare the system against how we expect the system to  behave. That's what required characteristics are. So what I mean by that is you know let's say you're  in Sydney and the new Sydney Metro is being opened and someone wants to test the Sydney Metro well  what do you want to test you you think that the Metro should be able to speed up at a certain  pace break at a certain pace you need to be able to you know if you develop something where you can  check if the Metro train behaves like it should then you basically try to verify the Metro train  itself so verification in a way is testing you know like we think of you know we understand  testing. So think of verification as the word to just say, like, if I verified something,  it means that I've gone through some set of tests in order to make sure this thing behaves how it  should. Now, the definition we have here is that verification is checking if the system has been  built correctly. And you should know how, you know, whether something's built correctly. And  this is true for pretty much any engineering system. It's not just, it's not just, you know,  a part of software, for instance. This is true for mechanical and civil. In all those fields,  if you've done your job right you should know what a correct system is and if you know what a correct  system is you should be able to test it and if you can test it you're in a good spot right so  theory says so we write code to test the code but then we need to test the code we wrote so we write  code to test the code now so that's an excellent question and honestly that's one students don't  actually ask enough which is okay i get the idea of writing code to test my code but how do i know  that the code I wrote to test my code is correct?  How do I verify that my tests are correct?  We actually don't go into an exceptional amount of depth  in this lecture, but what I would say,  and this is kind of true throughout a lot of  latter year courses as well,  is that it's really, really important  to keep your tests simple.  I don't think it's something that to,  you know, like we do a little bit of this in 1531,  one, but not a super duper amount.  But it's all about simplicity.  Like so as a good example, in general, it's often discouraged  to include loops in your tests right Because like think about your code when you write it Like the more if statements you write the more else statements you write the more for loops while loops you write They all the sources of bugs typically in your code  So your test should be easy to understand  because good programmers can identify bugs in really simple code quickly.  Do you know what I mean?  And see if I can kind of do it.  It's like if you have a piece of code here,  and I know you've just started on 1531 this week.  you know if you say something like you know you know const no vowels equals vowels dot replace all  a with you know nothing and we do that for e and i and u right like let's take a really simple  piece of code like this a good programmer even a half decent programmer could look at that and  if a few of them look at that you could identify that that is not going to be you know full of bugs  basically right um whereas if someone was to come along and write like a funny for loop where they're  like for const val of of you know uh a a e i o u something like this right um and then they start  doing you know const no vowels equals you know like and this isn't to say that this particular  piece of code is particularly difficult right like it's still pretty straightforward um but  it's a little harder you've kind of introduced some areas of like things could go weird here  have i done a raise right have i have i looped correctly am i like you know even even that like  here's yeah this is a great example actually because if you made something like this  you know let no vowels equals that and then you wrote let no vowels equals this this will actually  have a bug in it because of scoping rules which i'm not really going to get into but the point is  like simple code is easy to identify errors so you also do never know whether your tests are  going to be 100 right and i love that someone's brought that up um in terms of like that that's  a potential thing that you have to think about because it's true we'll talk about that a little  bit more i don't want to get too off track there for the moment um poor software uh costs more than  500 billion dollars per year worldwide yes so different industries there's different costs to  software issues, right?  So if you're working at a company like say a Canva or Atlassian, if you have a bug in your  software, it probably is going to be pretty cheap.  That's why there's pieces of software often riddled with bugs.  Whereas if there's other, you know, take a good example might be like a car, right?  Like the anti-lock brake system, AVS systems in a car.  If there something wrong with that you have to recall the cars you have to recall a hundred million cars Or if there a piece of software wrong you know a cochlear implant or a um you know uh what are they called the heart the artificial hearts oh my god pacemakers um then they very expensive so it always costs money to fix  you know unverified software and it's kind of why we do it like if you think about it  writing tests to verify software takes time. And if it takes time, it costs money,  but we do it because the cost of not the cost of having issues with your code will probably cost  more than checking your code. And, you know, there's another question that sometimes comes  up in terms, which is like, how much do I need to test my software? How far do I need to go?  And there's no good answer for that because it all depends on what's the cost of getting it wrong.  so there's some industries where i've talked to people where they'll spend one hour writing code  like an implementation and then they'll spend 20 hours writing tests for it you know and then  there's other industries where they might spend an hour writing code and 10 minutes writing tests  for it there's no right answer but in general in most places writing tests is important because  you need to verify your software in some way shape or form now when it comes to verification  we can break it up into kind of two key areas one is what we call static verification and the other  one's what we call dynamic verification. Now, static verification is testing code before it  executes. And that's kind of a pretty simple idea. What that means is like, if you write code,  blah, blah, blah, blah, blah, you write code, and then at some point, you run node my code.js,  right? Everything you do that test the software somehow before you actually have to go and run  it on the terminal is what we call static verification. Now, you haven't learned anything  about static verification yet.  You're going to learn a little bit more about it soon  with you, Chow, I believe.  But, you know, a really simple example  of static verification  that you probably do all the time without realizing  is staring at your code, right?  Like you will sometimes look at your code  and be like, is there a problem here?  And what you're doing is you're essentially trying  to verify that it works  through your own experience and knowledge  without running it.  That's a form of static verification.  We're going to learn about a couple of forms in this course.  One is called, you know, type safety.  The other one's called linting,  Both of those topics come up very, very soon.  Um, and it's all about before the code runs, but the other part, which is what  today's about is dynamic verification, which is about testing whilst we execute the code.  which is about testing whilst we execute the code.  And that's the kind of test where we basically run the code  in a bunch of conditions.  And that's probably what most people think about  when they think about what testing is, you know,  because you could argue that there's many, many forms of testing.  But when a typical undergraduate thinks about testing,  they think I need to write some code to run against my code.  And that running part makes it dynamic.  Sometimes we call static compile time checking.  Sometimes we call dynamic runtime checking.  there's a bunch of different ways that you could kind of think about these things or reason with  these things as well. Now, this kind of gets us into another important theoretical point,  which is called software safety. Now, when we verify code, when we write tests for code to  make sure that it works, we will typically describe that process as making software safe  for use. Now, safety is a funny term. It's different from making software secure.  So cybersecurity and software security are big topics that you'll hear thrown around  all the time, right?  Like everyone's always talking about cybersecurity and, you know, cyber attacks and everything  else.  But when you think about like improving the security of the code you write is basically  a process of protecting your code from deliberate misuse or as is written there, misuse.  It's misuse.  So that means that there are people out there who are trying to intentionally break your  stuff to steal from you to harm you to do some kind of, you know, negative outcome on your end.  And that's why that's why we try and protect against that. But that's about like security  protections. When it comes to improving software safety, that's basically a protection from  accidental misuse. So it's fair to say that part of verification is also trying to remove bugs.  And anytime you remove bugs, you remove any issues with accidental misuse. There's a little link down  here that you can follow in your spare time which says around 94% of spreadsheets contain errors  for any given spreadsheet formula there's a 1% chance it contains an error right so if you're  reducing the errors in an excel spreadsheet you're probably improving your software's safety  and software becomes unsafe when its design or implementation allow for unexpected or  unintended behaviors particularly during runtime so like for example with that the obvious ones  are like reading uninitialized memory or writing outside of array bounds so if you you can write  outside of memory or you can write outside of array bounds and that isn necessarily a security issue with your code but it could cause a bug for instance um amin says wouldn writing outside array bounds in javascript not be much of  a problem because it's a language that manages its own memory compared to c correct yes exactly  so i mentioned this at the start that different languages have different sensitivities so for  instance with javascript we don't need to spend much time doing anything when it comes to  verification around code to make software safe in terms of memory. So a lot of that, for example,  are much more specific to C, which a lot of you have experience in, which is why we have that  example there. Speaking of C versus JavaScript, we're going to dig into that example a little  bit more. C is not considered a memory safe language. What that means, and now it starts  to click a little bit, it's like, what does memory safe mean? It means that on the topic of memory,  it doesn't prevent it from accidental misuse and C is not memory safe it doesn't protect it from  accidental misuse however JavaScript is you can't do an out-of-bounds error in JavaScript you can't  do uninitialized memory in JavaScript therefore JavaScript like many other languages is what we  would consider to be memory safe because of what JavaScript prevents it now JavaScript does this  dynamically at runtime that means that whilst the code is running JavaScript will be ensuring the  safety of the code that you wrote by checking kind of constantly hey can they do this hey can they do  that hey can they do this c there's no bounds checking at all so therefore um it is not memory  safe and that's because c c prioritize prioritizes performance over memory safety and this is a  general uh philosophy that you will see um throughout programming which is every time that  you do something that improves the experience, not every time, it's a bit dramatic. Most of the time  you do something that improves the experience, it will come at some cost. So JavaScript has a lot  more baked in safety, just like Java, just like those other languages. However, that comes at the  cost of performance because JavaScript has to do a lot more, whereas C is like, yeah, I kind of,  I'm just going to trust that you do it right. If you do it wrong, you'll get punished. But if you  do it right, I'll be really, really quick. That's kind of the trade-off that happens there. Now,  we're not going to talk about static verification today at all. This is just kind of a throwaway  slide. But static verification is a bit of an underrated topic because when we often talk about  testing, we often talk about it in the context of dynamic testing, writing code to test your code.  Whereas static verification is super super cool It often considered by people probably to be more reliable but it has its limitations as well So what I say and this is just kind of a heads up for the comparison that you experience later static verification like if I could only statically  verify my code or dynamically verify my code, I would probably always do it statically personally  in all of the projects I tend to deal with. There's some projects you can't do that in, right?  But a lot of software projects you can. However, static verification has limits. Not everything  can be verified statically and that's really really important as well so there are limits to that too  now moving on dynamic verification the real meat and guts of things today so dynamic verification  is the verification that's performed during the execution of software code has to run this  typically falls into one or two categories which is testing in the small and testing in the large  now there'll be tons of different ways that you'll ever see this described throughout your degree  you'll hear like unit testing and this and that we're going to talk about a few but in general  you can break most software up into like it's either trying to test a component or it's trying  to test the big thing now if i go back to the metro train example you can either be like okay  i got a test that when i move the lever up that the train speeds up and i got a test that when i  shut the door that it fully clicks and it can't be open that's what you consider testing in the  small you're testing components of the bigger picture whereas testing in the large will  generally be oh i actually have to go and check out the whole thing does the whole train move  correctly so it's the pieces coming together and there's not really a better or worse form of that  right because testing in the large gets you closer to the experience someone wants in the end but  it's not very good when things go wrong for instance if you uh you know all your testing  is does the train break on time and it doesn't well you don't really know where to look because  you aren't testing the underlying components so that's a really important difference as well  now this little quote at the bottom here i think is a really important one not to gloss over which  is that testing shows the presence not the absence of bugs and it's just you know practically this  will have very little impact on you because you know a lot of what most of you will end up doing  won't be testing that extensively all the time but the reason it's so darn important is because  you can write a million tests and all it does is reduce the amount of bugs that exists  right? So, but never in full. So for instance, this quote here, the not the absence of bugs.  When you test stuff you are trying to find bugs You can find more and more bugs but you never be sure that you found all the bugs someone also made a great comment earlier about um code i can remember the  exact quote but you know uh every line of code you don't write is bug free is a great saying  and every line of code you do write you can test to your heart's content to try and find bugs in  but it'll never be guaranteed to be bug free.  Now, the reason dynamic verification exists  and static testing has its limits  is because real world things happen  that you can't predict at what we would call static time  or compile time.  What I mean by that is you can write code  and maybe that code makes a network request  or it takes an input from a user  or it reads from a hard drive.  You can't be sure how those things are gonna go  until they actually happen.  you know, in reality.  Because if you're making a request to a website  to get some data,  there's nothing you can do before running your code  that will guarantee how the code will,  you know, that it'll work  until it actually tries to go make that network request.  And that's why we need dynamic verification  because most code is messy.  Most code deals with the real world in some kind of way.  Got a student saying,  therefore I should write everything in one line  to have as much bug freeness as possible.  yeah probably um but that's not really possible most of the time okay so dynamic testing then you  have to imagine it as it's about making your program more robust in the face of real and  inevitable things that will go wrong whilst the program is running uh that's the main thing and  the other part of testing that we don't talk about because you kind of break testing up into two  chunks right the first one which is what i've talked about and what a lot of people talk about  is it helps reduce bugs in your code. Cool. Yeah, that makes sense. I'm sure we're, you know,  30 minutes in and most of you don't. No surprises there, I guess you'd say. But the second part  is that it helps you identify regressions. Now, regressions are a funny concept, I think, if you're,  you know, early on in your studies, because you haven't worked in very, very large systems.  But what often happens is, is you'll write some code. And then maybe a year later,  two years later, three years later, you or someone else will come and modify that code for some other purpose.  You know, you might say for instance need it to behave slightly differently.  That happens all the time. You might need a slightly different layout. You might need  um some other purpose. You know, you might say, for instance, need it to behave slightly differently.  some other purpose. You know, you might say, for instance, need it to behave slightly differently.  That happens all the time. You might need a slightly different layout. You might need  to have it take into account a new thing. Good example might be, you know, Australia recently  changed their tax brackets. So there's going to be code out there and tons of websites and apps that  had the old tax brackets and now there's new tax brackets for income. So they have to go and change  that. But the thing is, every time you change code, you risk the introduction of bugs. So by  having tests associated with code that we write, it actually gives us more confidence in being able  to change our code because we know we can change the code. And if it breaks the test, it's like a  stop gap to make sure we didn't screw something up. It's actually really, really important for  refactoring because if you write code and then you think your code's messy and you want to rewrite it,  if you've written it once got tests for it and you know it works and then you rewrite your code for  the same behavior and the tests still pass you know that you haven't broken something as part  of the refactoring whereas if the tests do break you're like wow i actually broke something there  so that's really important as well now this testing and the large stuff i mentioned um well  sorry that was dynamic verification sorry testing in the small um is small types of testing we are  typically testing a function is the most common way or a couple of functions. Another way you'll  hear this referred to is unit testing. Unit testing kind of means what it implies, which is  like you're testing, like a unit means a single thing. Atomic testing, that's not what anyone  calls it, but that name would make sense too. Unit testing, small testing, typically functions,  right? There might be some slight variations of that definition, but usually it means someone's  written a function that's being tested. These tests can either be black box or white box tests.  We also talk about this a little bit later, but the quick summary of it for now is that white box  testing is where the people who are testing your code know how the function works. Whereas black  box testers, they can test your function, but all they know is what gets put in and that they can  expect an output from it. And there are two different types of testing that have pros and cons.  If we compare the small testing to the large testing, the large testing is less concerned  with making sure every single little part of your code is working and more that the big picture is  working and different people in different companies different institutions will have different definitions of what that entails so for instance i got a few here which says that we could write module tests integration tests system tests Now  again, kind of depends because like module tests, someone might define as like, we're going to test  series of functions together. And then integration tests might be like taking those modules, which  are series of functions and testing those together. And then system tests might be like testing the  whole system. So like a system test on a website would be writing some code that goes and tries to  log in a user and create a quiz and play that quiz like really high level it's nearly trying  to emulate people or you know the the end user maybe that's a digital user or something but  end people and then as you go further towards the small they just get smaller and smaller  so the main thing I want to I guess point out to people is you might see something like in textbooks  they're being like these like here are the four types of testing or something but  my experience and the experience of others I've talked to is just it's never quite that black and  why it's really simple large complicated pieces of code will probably have many different layers  of what people refer to as tests maybe there'll be like five senses of abstraction small pieces  of code there might be like a couple but the point is that there are layers from small to large  where small is typically functions and large is typically emulating a user that's the main stuff  there now code time because code's lots of fun we're going to try and do some what i call naive  testing. And the here's the question, if I left you alone  right now, how would you check if this function works  correctly, you've got a function called get even it takes in  nums, nums is implied to be an array, it creates a new array  called evens, it loops through every num, if each number is  even because you divide by two and see if there's no remainder,  then we push that number to the evens array. And then we return  evens. Now, what would you do if I asked you to test that?  right? Well, you would probably go and try and write something like this. So if we pull up this  code, for instance, it's still in the old one. Or is it even testing one? Yep. So if I said,  Yep, there's some code, let's just first go and run it and make sure it works.  node num testing and the right folder even testing sorry  even testing one does like that if i go console log hello oh not hello sorry yeah just make  sure this works easy yep hello works there and then if i was to go and grab this code for instance here paste it it not pasting come on friends  triple paste no idea why so there's our code there and then if I go run that what I can see  is that the result is two four and six and seven so I've kind of tested that in a way there I've  kind of verified that it works verified this is a good example of like as you write tests you can't  prove that the code works but you've demonstrated that you've taken steps to reduce the the theoretical  chance of bugs because there's lots of different things i could put here lots of different numbers  you know i'll never be 100 sure but it helps me be sure and i can see okay for one two three i get  a two for four five six i get a four and six and for seven i get nothing it looks pretty good  um now that's all sweet and dandy however what are some problems with that  YouTube friends?  What are some issues?  I'm waiting.  quite a quite a quite a delay on the stream i think  negative numbers someone says negative numbers that's true we didn't test negative numbers  not enough repetition of tests have not tested negatives or a way to break the code  nums being empty um you haven't tested how it reacts to non-numbered data types  wow so everyone has actually expressed a huge uh quantity of amazing answers um there's actually  so many i can't even go through them so the main common theme is people have been like you didn't  test xyz and that's great that's the that's the essence of testing is figuring out what to test  and making sure that you test bunches of things right negative numbers empty lists giant lists  big numbers. Um, and someone's also saying, I'm guessing how,  how well covered it is. Yep. That's great. We're going to  talk about that in future weeks as well. Um, I haven't tested  how it reacts to non-numbers. Yep. All of this stuff is very,  very good, but there's this one person at the end with no  specific name who says you need to look at it yourself and think properly to see if it is correct So everyone right there but that the one I really wanted to nail into which is that it relies on my in the moment uh human judgment And if I run it again to check it again I  constantly having to do that checking myself. So the next thing you might do if you're writing  tests is write something like this, basically try and like, quote unquote, automate it a little bit.  My word, it just really doesn't like,  there we go i have no idea why it does that but that's okay  so if i go and change my test basically the same code here now right it's just that um  what's wrong why is it sad  see look this is me right now doing static verification trying to figure out why the bloody  there it is that's what i was looking for see that was just me statically verifying code that's how  simple it is right um so now i go and run this and what i see is it says doesn't work one doesn't  work two doesn't work three that's odd because that should work probably not really comparing  things correctly there um it's very difficult sometimes in in javascript and languages too  this is a very kind of loose piece of code but you really got to be careful um when you can  need to be literally equal to should should work fine i don't think that'll matter because that's  like it's like softer without it um but usually like usually what's happening here is like it  might not be literally the same list or something like this right and this code wasn't really meant  to be run um it's mostly just trying to say like the point here is that you are now doing something  where it is checking if it's correct  and then it is simply telling you if it's wrong.  So if each of these is correct in some way,  then you'll be in a better spot to tell  because it should just print nothing.  And if it prints text,  then you know you've kind of screwed it up.  So it's automated.  So back to that bureaucratic participation mandate user.  That's the point.  You need to look at it yourself  and think properly to see if it's correct.  I don't need to do that anymore  because it will be telling me.  Let me just, yeah, so this person said,  you're not able to directly compare an array.  You can't do that.  You're gonna have to compare it another way.  We actually go through an example of that.  A few people have some ideas. directly compare an array. You can't do that. You're going to have to compare it another way.  directly compare an array. You can't do that. You're going to have to compare it another way.  We actually go through an example of that. A few people have some ideas.  It's kind of difficult to compare two arrays in JavaScript. It kind of depends on the language.  Some languages will make life really, really easy for you. Sometimes languages like JavaScript,  they'll come out with new and new features. We kind of talk about this sometimes in previous  terms, where like they're trying to think you guys haven't learned about JSON yet,  because I guess we're going to do that next. But yeah, like one really simple hack around this,  if you want them to is like you can kind of just compare the length of them or something,  but that doesn't really work. We have when we do jest, which is the next topic, I'm going to show  you how to compare arrays really easily. This doesn't work because the definition of this in  javascript is it's trying to check if the objects are the same it doesn't actually automatically  check if the items are in it what i mean by that is like if you hold up two blue shirts in front  of you are they the same shirt literally no but they just happen to be the same color you know  and yes there's lots of ways we can fix this it's just it's not the point we weren't even meant to  run this we're just kind of meant to show you that hey instead of having something like this  you can turn it into this and then it's automatically going to tell you if something's  wrong. However, the problem with all of this is it's not really testing. Printing errors or  visually inspecting output is a method of what I generally refer to as debugging. Debugging and  testing are ways to figure out what is wrong with your code, right? However, debugging is not  something that scales well. So what I've got here is saying you can't really call something a testing  method if it doesn't scale well to a system. If it's code you write that checks if something's  working or is just trying to poke it and understand it that's just you debugging code  testing is a scaled approach um and that's the main difference with debugging now before we go  learn about testing in more detail and how to do it properly because this was just the spirit of  testing want to quickly talk about black box testing so black box testing is a notion of  abstraction that essentially says when we test something we don't need to understand how it  Now this is a very difficult concept to grasp,  even though it a simple concept if that makes sense You know like you probably come across many of these in your life where like it hard to make sense of for a lot of people until it makes sense then it like oh that kind of totally obvious so some of you might find this a little bit odd at the start  um the way i often like to explain it is like if i said to you you know let's say you and i  gonna go pick up a car secondhand car we're going to um you know condo park in sydney and we're  going to go and pick it up well you're obviously going to say we should quickly test the car that  it works first right now you might not know anything about cars and i might not either so  what do we do we go to the car it's a hyundai i30 some random car i don't know much about cars  you hop in it you turn the key you ignition on you put it into drive you drive it around a bit  you turn the wheel you accelerate and you brake and you pull the handbrake up you don't really  know how that car works and you're not really testing the car like actually does all the right  things under the hood what you're testing is that like you gave an input which was steer left and  the car steered left you don't really know how it did that if i asked you explain that to me most  you couldn't right if i asked you how the accelerator works and the engines work you'd  be like i don't know either but you're like accelerating down car goes forward that's the  function the inputs the accelerator the outputs the car going forward the in-betweens magic now  Now, when it comes to a lot of testing code, we actually employ the exact same concept and principle, which is that we look at a code in terms of it has, it's a function that does something and there's an output.  And we don't really care about how it works in the middle.  Now, the reason this is hard, I think, for a lot of people to grasp initially is because you often are writing the code right now that you're testing.  So, you know how it works, you know, so it's hard to kind of separate yourself out from that because you just know how it works.  So when we go, oh, let's test your code, you can't stop thinking about, it's like nearly  asking the, you know, the person who built the car to test the car.  They know how it works.  So they can't think of it in such abstract terms.  Right.  But when we look at software, we often want to test like that.  Um, and we call this type of testing black box testing.  Now, why would we ever do that?  If we understand how cars work or if we understand how code works.  well even if you understand it it's important because what you're doing is you're decoupling  the implementation from the testing you're giving the person who basically you know builds the thing  some freedom to not be constrained by your understanding i if you write some tests that don need to know how the the car works under the hood or the code works under the hood the person who writing the code can go change it without your stuff breaking you know And that a good thing  Another example of that might be like, you know,  let's say that you're giving someone some ingredients  and they're gonna go make a cake  and bring you back a cake.  You can test and say, if I give them this X, Y, Z,  they'll come back with this food.  If I give them A, B, C, they'll come back with that food.  That's a form of black box testing.  however white box testing would be you going deeper and actually being like i'm gonna i'm  gonna give them this food and then i'm gonna check if they get the pan out and then i'm gonna check  if they put the oven on at the right temperature and then i'm gonna check that they put the food in  they followed this procedure now the good thing about that type of testing that white box testing  is that if you have access to all of those details you know like the cook and all like exactly what  they're doing yeah sure you can finitely improve your confidence and that they're doing it right  because sometimes things and this is important sometimes things can go right for the wrong  reasons and that's bad what i mean by that is sometimes the car that you test might drive fine  even though it's overheating because that has yet to affect it so when we go into the detail  white box testing and we actually make sure all the little components are working we're even more  sure that it works however our tests now rely on understanding how it works and that's not  yeah so someone says white box testing sounds like micromanagement yes and what do we know about  micromanagement that um it generally improves the outcome but doesn't scale would be a really  simple way of explaining it so someone else has said can't know what to exactly test though unless  you know what it does and what might go wrong correct yeah so typically i'm really dragging  this one on typically white box testing is reserved for the people who wrote the code and  it's generally reserved for unit testing or testing in the small. So if you write a small function,  you might white box test it because you understand it and it's quite small.  Every other type of testing is generally black box testing. And even a bunch of unit testing is  often still black box testing. And in this course, all the testing you do is black box testing,  because that's what most of testing is. So we're trying to really convey that point.  Now, what I mean, you know, and if you're still struggling to understand me here a bit,  a function here called remove vowels and factorial.  I'm going to go and open them up.  Now, when it comes to  these two pieces of code,  if I say to a student right now,  go write me tests for the code The first one returns a new string with the vowels removed the second one calculates the factorial of a number right write tests for it now i not saying you  specifically but a lot of people their brain will freeze up and say i don't know how to write tests  for it because it's not finished yet or i don't know how it works and that's the really interesting  conceptual gap to bridge because you you don't know how it's implemented but you understand what  it does because we have to unpack that phrase how does it work it's like well i i know how it behaves  but i don't know how it how it gets to that behavior i could explain it a bunch of different  ways so what i mean by that is like i know that remove vowels takes in a string and i know that it  you know returns it with the string removed so i know that if i was to say you know uh if um  remove vowels takes the string cat.  If it does not equal, what would that look like without the vowels? ct.  Console.log error 1.  And then I could write another one. If remove vowels on dog  does not equal dg  then console.log error 2.  Right? And what I'm doing here  is I am black box testing  because as LL has said in the chat,  I just want the result.  I don't care how you get there.  Here's the input.  Give me the output.  I don't really care about the details in between.  And the cool thing about black box testing,  which is really critical to your first iteration  is that it doesn't,  the functions don't need to be finished yet.  You need to know what the function takes in  and what it gives out, right?  Everyone has to agree on that first.  But once that's agreed upon,  you don't really need it to be done.  I can go and write these tests.  And yeah, when I run this code now,  blackbox.js, when I run that, it will give me errors. The way I describe this is that the code  runs perfectly fine, but the tests fail. And that's okay, because then what happens is that  a developer comes along later, and a developer goes, well, okay, I'm going to say new string  equals string. And then I'm going to, you know, say for const vowels of, you know, in, yeah,  I'll do of a IOU like this.  And then I'm going to go  and I might make another test here just quickly,  just to really, you know, let's go Google,  which will give me like digital.  And I do that and I say, well, for each of that,  I'm gonna say new string equals the current string,  but I'm gonna replace say new string equals the current string  and I do that and I say well for each of that I'm going to say new string equals the current string  but I'm going to replace the val with nothing so then I go sweet okay cool but now I run that code  and it says val's not defined what is it val that's what I want  cool and I still get error one two three and I'm like okay what's wrong there well I didn't return  anything silly silly silly there we go new string run it again error two I'm still getting an error  two and what's happening here I mean I know this because I've done this example a couple of times  what's happening here is we're only removing one val and I can see that just by debugging my code  right now a little bit by printing out new string before I return it seeing what my code does and I  can see the extra o's there and that's because in javascript replace will only replace the first  instance by default and I need to use replace all if I'm going to replace all of them and now I run  my code and I don't get any errors and therefore my tests have worked and this is this is like a  pretty basic conceptual workflow around like you have to agree on what certain functions or systems  input and output someone can go and write tests for them independently of someone implementing  it now in reality people might do these two things concurrently a lot of companies will end up  writing the tests after their implementation, just because everyone's under pressure in the  real world a lot of the time. However, as part of trying to get the practice right,  we want to teach you the right way to do it, which is you write tests and then you write  the implementation. And, you know, it's not only the, like, there's not, like, it's a good thing  to do in terms of principles, but it's actually really nice to write code once you have tests for  it. Like if you sit down and you write tests like these ones, and then you do what I just did,  it's really comforting when there's no errors. Cause you're like, I know my code works, right?  There's none of that existential angst that comes from finishing writing code and being like,  I hope it works.  You know, it would really suck if I've got something wrong.  So that's a pretty great aspect of things.  Yep, that's kind of just what I talked about there.  Sweet.  Now, I think we've conveyed all the points, personally.  If you do have any questions, then feel free to throw them my way.  But, you know, the next thing to get into is about how do we actually test code?  So to test code at scale we need a real testing framework And a framework is basically a system that is designed specifically for testing Now Jest is a framework used in JavaScript both with Node and  JavaScript on the front end. And it's installed with NPM, which Yushao has already talked about.  Now, if I just quickly Google NPM JS Jest, I want to give you a sense of the scale of this  particular testing framework it has 20 what yeah 20 million downloads a week i always love to do  this 20 million divided by seven days divided by 24 hours divided by 60 minutes divided by 60 seconds  33 downloads a second now i want to be clear this isn't 33 new pieces of software this is 33  developers a second in the world or systems that are downloading it to run it so a good example is  a company like canva if it's got 5 000 employees you know all of those employees might you know  once a week or once a month get a new version of jest as it comes out so you know across that  company of 5 000 people making one app that might be like 5 000 a month um at canva download it for  instance or for instance as that system is released every evening and we talk about these concepts  later on in the course i don't know if you chow or i does it but someone does it's like you know  these systems like every time Canva releases new update it probably goes and gets a fresh library  as well so there's a lot a lot of downloads that happen here but it's a significantly popular  library and it's popular for a reason it's pretty easy to use it looks like this and the way it  works is that it has a little structure where you essentially say yep I'm going to give you like a  high level idea and and then you can write a test like this so this is the test line this is the  equivalent of the if statement that you might have seen in the previous pieces of code now  what it does is you give it a an element here like a name right and you say i expect the value of that  name to be equal to the string hayden and that's what it will do and it will basically crash or  throw an error if it doesn't equal be equal to that um so now we're going to go and do that  ourselves what i'm going to do is i've got a file here called just lib it has my remove vowels  function in it that is yet to be implemented. And I'm exporting that function here as well.  I then got another file here called just lib test. And what I've done is I've gone and written a  bunch of tests in that file Now the important thing to notice here is I am importing remove vowels from just lib So I got my implementation in one file here It not done yet It just called being stubbed And that mean a lot to you after iteration zero right  Because in iteration zero, you went and stubbed a bunch of code. So you've got a lot of code that  looks like this, right? So you've got your, your implementation is currently stubbed. You export  the code, you import it somewhere else. And what I'm doing here is I'm testing with that export.  and I'm just simply saying, well, hey,  I expect that if I remove vowels from AEI,  I get an empty string.  IOU, empty string.  ANT, NT, old, old, something wrong there.  All right, think about that for a second.  B gets me the letter B.  Hi gets me the letter I.  Cannot gets me C-A-N-T.  Delicious gets me delicious  with a funny little symbol there.  It's also a little bit of an Easter egg.  So we're going to go and test that now, which will be fun.  First name in the chat has asked, are there any moderators in the chat?  I'm not sure.  I can be a moderator regardless.  And Claudia said watching from Angola, Africa.  If that's the case, that's awesome.  Technology.  So I can go and write these Jest tests.  Now, as part of your iteration one, you'll be writing Jest tests like this, right?  I haven't.  I'm not going to show you me writing them because we don't want to spend forever on this.  But I've written them before.  They come up like that.  and then the next question becomes, well, how do we run them? You know, and I run them by well,  I have to install and I have to install Jest into my, you know, my folder, or in your case,  your project, right? When I do npm install, save dev for Jest there, what will happen is that it  will go and install it, right? You went through that with you chow in the npm lecture, you can go  and review npm if you're not too sure what that does. The save dev command, remember, it really  has no impact on anything for you at this stage but any time that you install a library that is  meant to is only really relevant for um how would you put it uh it's only relevant for  the development of things it's not in production what i mean by that is like when we write tests  right? What will happen is that the developers care about that, right? But when we actually go  and deploy that into the systems, it's not really tested as much at least typically. So what I mean  by that is like when something actually gets dumped onto like say a Canva server or Google server they not often testing it in production they done all the testing before that point now that that kind of like distinction is not super super critical so if you don really understand  it yet you can kind of sit on it for a little bit i wouldn't worry too much but now i've gone  and installed jest the next step is to run it right so if i've got my little bit of test here  I can run this particular piece of code here and it should work totally fine.  Just a quick interlude.  People have mentioned there's a fair bit of unrelated chat that's a bit distracting.  All I'll say is that if good questions come up, I make sure I answer them on my voice.  So for anyone who's not tuned into the chat or watching the recording or they watching  live, but they just want to close the chat because they don't want to really read it.  I make sure that anything that comes up there, I address in the lecture itself.  So you can, regardless of how noisy someone is,  I'll make sure that's covered.  Now, if I want to go and run this,  I do exactly what's there.  And this is a really important line.  I have to run this command here.  Now, if you remember from the NPM modules lecture,  when you install stuff,  it all gets installed to the node modules folder.  If there are modules that are installed  that have a particular executable,  i.e. they're not just libraries,  but they can run like programs,  then they'll typically be in the .bin folder.  And then for anything in that .bin folder,  like Jest, there's Jest.  So Jest is a program there, right?  Now I've just tried to run it.  Jest without any extra parameters  will try and do a few things.  What I'm gonna do instead is I'm actually going to give it  a particular file to run here.  And in that case, the particular file I wanna give it  is Jest lib test.  So jestlib.test.js.  So I give Jest a test file that I would like it to run.  right so when i hit enter on that it will try and run that there now it is mad at me because  i'm not sure let me have a look  just failed to pass a file we might be missing some code let's see  Let's see.  I haven't looked at the lecture code in terms of,  there might've been,  someone might've dropped something while copying it.  Let me check if it's there.  I don't think it'd be there.  Let me go check what's on your, there might have been someone might have dropped something while copying it let  there might have been someone might have dropped something while copying it let  me check if it's there I don't think it'll be there let me go check what's on  your um I think that's just a file missing this file I think is the file I  want I'm not sure why it's not there  just make sure it's definitely not there yeah so this is included in your repo because if you  don't have it um some things don't work i think that should be it that definitely needs to be  there let's just check if that's the only issue replay let's go and run it again  just lib should work yep so this one worked here and you can see that i got a whole bunch  of stuff here it was like you know one failed five failed now that makes sense because let's look at  the bloody file it's not implemented this is what i was saying earlier about your code can run  correctly but still the test can fail because there's a difference between your code just  failing to run and it running successfully to tell you that everything went wrong you know  just like a funny little thought right because at this point in your you know illustrious career  you probably have a very one-dimensional view of that now we can see that everything failed here  It's saying that there was one set of tests, basically one test suite here.  There were five tests within that and five failed out of the five total.  Okay.  Well, that's good.  So this is what will happen in your project.  You will, you will go and have a, you will stub your code, you'll write tests for it.  You'll run it or your tests will fail, but you're happy with your tests.  So then what you do is, you know, besides committing your code and stuff, you go back  here and you go and implement the darn thing now.  So I'm just going to go and copy and paste my code because we've already done it.  Yeah, there you go.  And now I'm going to go run my tests again because I've written my implementation.  It's time to double check that they work using the tests that I've written.  OK, now, in this case, what's happened to a failed three of past tests failed successfully.  I love that.  Yeah, exactly.  Now I can see here that what's happened is I've actually got errors in my test.  Oh, no.  So someone asked that great question to start a lecture.  what happens if people  write tests wrong?  Well this happens right Is they actually might learn it during implementation In general it something you should avoid Clearly here I got an extra O whoopsie and I got this extra character that I must have tapped whoopsie So I would go and you know update that run this again  Now it works. Great. So I passed on my test. Now I made this reference earlier about  regression. And what I'm saying by that is like, if you went and say you were like,  no, I want to rewrite my code, I don't really like it. So you simply go and say, you know,  string equals string dot replace all a with nothing. Say you want to implement your function  this way. Now I don't know why you would do this, but I'm just giving you an example.  If you would do that, also new string here is Yeah, so here's a good example. Let's say I did  that. Now I was about to hit save on that before I noticed my bug. But you see now that I do that  when I change my code for the same behavior, because I've cleaned it up, say I run my tests  again suddenly all my tests fail oh there you go well not all most of them and that's so useful  that's so useful because now i'm like oh my god i had this like guardian angel here that i wrote in  the past that has helped me understand what's wrong and if i had a look i would identify that  that was the error i'd run my tests again and i go oh thank god i had that because now i can clean  up my code confidently you know knowing that it's all going to go okay so that's jest in a nutshell  like the cool thing about jest is structurally, it's really simple. It's like this format.  You know, it's this format here. In the lecture code, we have more in the sorry, we have more in  the lecture slides as well. This is straight, this is taken straight from it. Obviously,  the lecture slide code code has the errors in it that I was trying to demonstrate. So keep an eye  out for that. Pretty easy. And you know, we can run that totally fine. The next thing though,  which is fun, is that if we just run Jest without the extra variables, what it will do is it will go  and run all of the files that it sees in that folder that has a dot test dot js on it. So that's  a really useful thing. In fact, I'm pretty sure it just does it in all subsequent folders. So in the  folder 2.3, it looks everywhere in the code base, and looks for everything with dot test, and it  will just run it. So I can just run that Jest part there. However, if I want to simplify my life more,  what I can do is I can go and add a line to my scripts here, where I simply I don't need the  source part where I can simply say Hey if someone runs npm run test I want you to just run the Jess command Now you don need to write it out like this You could this would work perfectly fine And just for simplicity I show you this one So I say in my scripts if I run test it should execute that command That the command I have  on the terminal, npm run test, it'll go and run it for me. However, this script stuff,  it actually, if this makes sense, if you just give it a word, the way that like these unique  systems work is they kind of go like jest okay i have no idea what the hell jest is so then they  go look through a series of pre-defined areas for it and one of those predefined areas is this folder  so even if i don't have that it will still work because it's going to go and look for  jest commands left right and center and one of those places will be that spot so that doesn't  really have much of an impact it just simplifies your code there finitely for you cool so the  general structure of tests is that the outermost one like there's no there's no real rule in thumb  like this outer describe will typically be like trying to describe what all of the series of tests  are like and then what you put inside the test string here will describe what am I actually  testing and you can also wrap these things in as many describes as you'd like you wouldn't really  do this for tests this small but you could easily wrap that in yet another sorry wrap that in yet  yet another describe no issues there at all um it's all just a textual structure right like  it doesn't the words here don't mean anything like you could replace all of this with just like  you know literally emojis that would be not problematic at all um it's just that when the  see see how nice this is here with the outputs it's saying yet remove vowels here's the tests  that it passed. Someone says, is each describe one test suite? That's a great idea. I always have  a love for if we don't know something, let's try it out. So what I'm going to do is I'm just going  to go and break this up really quickly. I'll take two tests and three tests. I'll paste this here.  I'll call this one remove vals2. I will go and run it again. See what it gives me.  Still one test suite. So it's treating the test suite basically as a file, right? That's the  answer to that question. But now I've got two sets of describes and I can break that up. So again,  the whole point is that all the text stuff and describes and tests are just artificial structure.  Now they important so that you and everyone else understands what going on of course but there no real sense of getting it wrong except if people are confused So it a very human thing You need to make sure it works because other humans need to understand it Yeah There more general structure This is a great piece of code to copy and paste  If you're starting writing tests for iteration one, because, um, it just gives you  a really basic example, you know, no issues there at all.  Um, note the JS syntax relies on some ideas around function, function syntax and function  callbacks that won't be covered for another week or two that's fine to use jest in 1531 we've had  to add set a few environment attributes this means you should only be able to get just working week  three labs iteration one onwards yes so what i mean by that is that um i think when the lecture  code was copied for this term this file was probably missed this happens when um uh this  hidden files can easily get missed but the point is these things here like this file  and how the package.json is set up,  which is specifically this line here.  Those two things are critical for Jest to work properly  based on the code that we've given you in the course.  So what that means is just from your perspective,  this will only work generally in the week three lab.  So if you want to go back to your week one or week two labs  and test something, you probably need to modify it slightly.  But again, that's more just a disclaimer.  Most of you won't ever go near that.  So that's no problem at all.  Cool.  Okay.  So a few more concepts.  How much we got left?  Yeah, not long.  Design by contract.  This is something we kind of glossed over at the start  because we figured, you know,  a little bit too academic for a while here.  So let's get back to it.  When we're testing or implementing a function,  we'll typically be working with information  that tells us the constraint placed on at least the inputs.  So what I said to you earlier was that  typically everyone has to agree on what a function does  before they test it or implement it.  this process generally is what we call design by contract.  Contract is like an agreement.  Design is like how we approach things.  So we have to agree on stuff at the start.  You kind of get that already.  However, what I didn't really touch on is that typically  there'll be an agreement about the bounds of things.  Because there was some great answers earlier about  what happens if I pass in a non-number or a non-string or null or something.  And usually teams of people will kind of agree on like,  what are the limits of these things.  So for instance, in this case, they might say like,  oh, well, this function returns a new string with vows removed.  The input is a non empty string and the return type is another string. case they might say like oh well this function returns a new string with vows removed the input  case they might say like oh well this function returns a new string with vows removed the input  is a non-empty string and the return type is another string now you might be like well what's  the point of that why don't like what if someone passes in something else you know like no i could  pass in a number and the answer is because typically functions are used in the context  of bigger systems what i mean by that is if someone is calling the remove vowel function  And the person calling it might be calling it in a place where the numbers they're passing  in have already been checked and filtered by another function, you know?  And you might be thinking, well, sure, I get that.  Okay.  That makes sense as a function.  And it's like, you know, we kind of know that the inputs are going to be, um, checked a  certain amount so we can document that so that, you know, someone knows that it's going  to be expecting something.  Then you think, yeah, but what if someone just like abuses it?  You know, what if someone just like totally just ignores that?  it's like well that happens too but that's why we pay developers and engineers and encoders good  money because we expect them to read the documentation and be like yeah input is a  non-empty string type and to behave like that now again we're getting into philosophies here because  there'll be certain types of industries and systems where even if you document what it  expects to take in you will still code in some checks that are like what if someone just ignores  it and they're typically higher high critical systems and stuff you know where if something  goes wrong someone might die or something might explode um if you're building a little like app  like duolingo or something okay what if some what if a bad engineer ignores some code what's going  to happen the website goes buggy you know so again i'm not saying that that would be okay but it's  like important to understand the scale of what we're talking about affects how we'd approach stuff  behavior this is a really important note as well so when it comes to software behavior  we don't talk about it a lot as far as i've seen in first year but behavior is a really important  word and we use it to just describe what does the software do you know so someone might say  what does it do but like what you're really asking is like what's the behavior of the software  so when we test software we're essentially testing the behavior of the system right  because behavior if you think about it is just how people respond to you know stimulus i guess you would say and software is kind of the same you poke it it does something you poke it it does something you know like that um however it not possible to understand the behavior of every possible scenario right um and that just is because sometimes  it's just not feasible because it could be a million different things and the other time  is that the implementation details are not critical to kind of the spec or um you know  it's just like not intended to be used that way so there's actually a good example of some of these  in c and the reason i mention it is because there's this concept called undefined behavior  undefined behavior is where behavior is not defined at all often because the use case is  beyond reasonable scope of expectation um so what that means is there is code out there where i  think i think a good example is in c right like in c if you say um like int main and then you say  int i and then you say printf wrong wait yep yep that was right printf i like this i'm i'm 90 sure  but i'm pretty sure that if you kind of go read through the c book and you're like what happens  here right because i is not a value i haven't assigned it anything it's it's it's i think it's  undefined behavior and what that means is the people who wrote c they didn't like they didn't  like want to build in all these different specifications and systems and be like this  this is exactly what happens in this case they were just like it's kind of not really how it's  meant to be used or like you know so like we don't know what's going to happen is the short answer  i mean you kind of could guess but it's not clearly defined the answer is it'll just use  whatever's at that memory address on the stack previously it could be zero it could be something  funky um so that's that's what undefined behavior is in a nutshell and the reason we point that out  is because occasionally when it comes to a big project like the one in this course um there'll  be questions people might have like you know oh what is what happens if xyz or like you know a  good one we get off in an iteration two is like what happens if the server shuts down halfway  through something something and we're like you know we don't know like anything could happen  and typically anytime you might hear about undefined behavior in labs or the project  it usually reflective of the fact that um we don test it either because if it was defined we be testing it oh this is just a quick note this isn really related to the course but whilst we talking  about behavior this is kind of important one of them's called another idea is called implement  implementation defined behavior it's usually when um  it's usually when the people who set a standard don't really care about how someone does something  they just are like well you know as long as the box is a certain size and a certain color we don't  really care about whether what exact shade of red it is you know and i think i don't want to go too  deep into this because it'll take up time but um quite often people set standards and then people  implement standards really good example might be like um you know the government during elections  there was a state election recently uh council election sorry new south wales and you know the  the aec they might have rules about you know you need to have this many boxes and this many stalls  it needs to be open from nine to five and blah blah blah blah right like they've got all their  rules their spec but then someone might ask a question and say hey what is the a where does  the aec think we need to put the the bin you know the bin where people throw stuff out and the aec  not that this conversation actually takes place but they might just be like that it's not part  of our set they might say that's an implementation defined behavior they wouldn't but they might be  up to you right they're like up to you there are a thousand people like you implementing the  standards that's a really detail specific thing so it's like it's kind of up to you because it  doesn't really matter they're like it's not part of the behavior they expect therefore it's not  something they'd ever test or check therefore they're like it doesn't really matter so kind  to do what you want there um and the same thing happens in software a lot is that there might be  like a spec right that someone has to implement because think about it there's one spec for the  project but there's 200 groups okay so in all those 200 groups there might occasionally be  some aspect not so much early on in the project but later on where like someone might interpret  something slightly differently um that isn't to do with the spec and they might just be like a  tutor or someone might just be like it's kind of up to you implementation specific behavior because  you the implementation So good example here is like where the text inputs ASCII or UTF encoded So ASCII is like the old school type of text you know all the alphabet numbers and stuff And UTF includes like all the new emojis and things like that blah blah blah So you know if you ask that for a tutor  they'd be like, that's kind of implementation specific.  We don't really care because we're not testing  and it's not part of what we're trying to do.  So that's a cool little fun fact.  This is a cool little snippet right at the end here  that just kind of shows the differences between testing.  Byte-byte-go does a bunch of cool stuff.  This is just kind of taken straight from them,  them but they're kind of just showing you know and i love this i love this diagram because maybe i  can make it slightly bigger i love this diagram because it kind of shows you that like i never  talked about load testing here you know um but that's like a real thing these days in big systems  it's like testing won't just be like writing code to check if the code works it'll be actually um  writing code to check if the code that does work can withstand large volumes of stuff right  like for instance netflix would be doing a lot of load testing as part of their dynamic verification  because they'd be like we have 100 million users i don't know how many users they have we have 100  million users and we know that when we release this new tv show that statistically the worst  case scenario is that 30 million of them might try and watch it at the same time so they might  go and test their code and their systems more broadly by like just trying to make 30 million  requests at the same time and see what happens you know so testing is a big big concept which  is and it's always evolving right like load testing wasn't as big a topic for graduates  20 so years ago because like you know back when we used to um sell software and cds there was no  notion of load you know like if you know you play a video game they don't need to load test a video  game but duo lingo needs to load test it because what if everyone on the planet wants to learn  spanish at the same time you know so these things evolve which is why why i think it's so important  you get the gist of it and i don't leave you with here's the four types of testing that exist um  so you know that's good anyway that's it um cool let's take a quick break um  and then we'll get stuck into the next part so we'll just do we'll just do like  three or four minutes um we don't really need to take breaks with live streams as much so um  yep cool chat in a sec